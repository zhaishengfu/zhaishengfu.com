<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta name="keywords" content>
    <title>
        zhaishengfu
    </title>
    <!-- favicon -->
     <link rel="stylesheet" href="/css/style.css">

    <!-- highlight -->
    <link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/github-gist.min.css">
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad()
    </script>
    <script src="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-infinite-scroll@2.0.0/dist/main.js"></script>

    <script>
        infiniteScroll()

        window.addEventListener('DOMContentLoaded', function () {
            const [
                mainTitle,
                mobileMenu,
                mobileMainTitle,
                mobileMenuBtn,
                ipadMenuBtn,
                aside,
                closeBtn,
            ] = getEle(
                '#main-title',
                '.mobile-menu',
                '.mobile-menu h3',
                '.mobile-menu button',
                '.ipad-menu',
                'aside',
                'aside .close',
            )
            const io = new IntersectionObserver(entries => {
                if (entries[0].intersectionRatio <= 0) {
                    mobileMainTitle.classList.remove('invisibile')
                } else {
                    mobileMainTitle.classList.add('invisibile')
                }
            })
            io.observe(mainTitle)

            clickToggleAside(mobileMenuBtn)
            clickToggleAside(ipadMenuBtn)
            clickToggleAside(closeBtn, false)

            const isMenuVisible = window.getComputedStyle(mobileMenu).display !== 'none'
            if (isMenuVisible) document.body.style.background = 'none'

            function getEle(...args) {
                return args.map(arg => document.querySelector(arg))
            }

            function clickToggleAside(btn, show = true) {
                btn.addEventListener('click', function () {
                    if (show) {
                        aside.style.display = 'block'
                    } else {
                        aside.style.display = 'none'
                    }
                })
            }
        })
    </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container">
        <header class="header">
    <nav class="mobile-menu" style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
        <h3 class="invisibile">
            <a href="/" class="logo">
                zhaishengfu
            </a>
        </h3>
        <button class="menu">menu</button>
    </nav>

    <button class="ipad-menu menu">menu</button>

    <h1 class="title" id="main-title">
        <a href="/" class="logo">
            zhaishengfu
        </a>
    </h1>
    <h2 class="desc">
        Math / Render / Game
    </h2>

    <div class="links">
        <ul>
            
            <li>
                <a href="https://blog.csdn.net/zhaishengfu">
                    CSDN
                </a>
            </li>
            
            <li>
                <a href="/zhaishengfu@gmail.com">
                    EMail
                </a>
            </li>
            
        </ul>
    </div>
</header>
        <main class="main">
            <article class="post">
    
    
    <h4 class="post-cat">
        <a href="/categories/渲染/">
            渲染
        </a>
    </h4>
    
    
    <h2 class="post-title">
        采样和重建(Sample And Reconstruction)
    </h2>
    <ul class="post-date">
        <li>
            2019-09-04
        </li>
        <li>
            翟升富
        </li>
    </ul>
    <div class="post-content">
        <p>Motivation: 渲染的输出是一张2D的像素网格, 是离散的. 入射辐射亮度实际上是定义在胶片平面的连续函数. 从连续到离散就必定会带来质量下降. 下降的多少决定了最终渲染输出的效果的好坏. 而从连续信号到离散信号的过程一般称为采样. 良好的采样方法应该产生低差异(low-discrepancy)采样点. 采样结束之后我们还希望从采样结果中能恢复原始信号, 这个过程叫做重建.</p>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<p>##采样理论<br>数字图像是一系列像素值的网格. 像素值用来决定显示的物理设备发射的光谱能量. 首先需要区分图像像素和显示像素. 图像像素是特定采样位置的函数值, 而显示像素是以一定分布发射光的物理器件. 物理器件使用图像像素值来构建显示设备表面的新的图像函数, 这个函数在显示设备的所有点都有定义, 而不仅仅是图像像素的点. 因而, 我们生成数字图像的过程实际上是将物理器件的连续图像函数用数字图像的像素离散化采样得到的.<br>采样中不得不提到的一个重要技术就是傅里叶分析. 傅里叶分析从频率与考虑信号的采样和重建的相关问题, 并可以用来评估重建信号和原始信号的匹配度.</p>
<center> 

<p><img src="/2019/09/04/Sample/sampleandreconstruction.png" alt="&quot;采样重建&quot;" title="Optional title"><br>Fig.1: 采样和重建</p>
</center>

<h3 id="频率域和傅里叶变换"><a href="#频率域和傅里叶变换" class="headerlink" title="频率域和傅里叶变换"></a>频率域和傅里叶变换</h3><p>傅里叶分析的基础之一就是傅里叶变换, 他是频率域中的一个函数. 事实上大多数函数都可以分解成偏移的正弦曲线的加权和. 这个惊人的事实第一次被<strong>Joseph Fourier</strong>发现, 而傅里叶变换就是进行这个分解的过程. 频率域可以给我们一个原始信号某些特点的更深入的理解.1D函数\(f(x)\)的傅里叶变换是:<br>$$ F(\omega) = \int_{-\infty}^\infty f(x) e^{-  \boldsymbol{i} 2\pi \omega x} dx$$<br>其中i是复数项, i =\(\sqrt{ -1}\). 并且<br>$$ e^ {\boldsymbol{i} x} = cosx +  \boldsymbol{i} sinx$$<br>从频率域当然也可以变换回空间域:<br>$$ f(x) = \int_{-\infty}^\infty F(\omega) e^{  \boldsymbol{i} 2\pi \omega x} d \omega$$</p>
<p>如果想要更深刻的理解, 建议去查阅更详细的傅里叶分析介绍.<br>我们考虑空间域常数为1的函数<br>$$ f(x) = 1$$</p>
<p>这个函数可以认为频率为0, 也就是没有任何变化. 但是整个基本区域的积分值为1, 所以频率为0的函数值可以认为无限大(并不是无穷大, 但是可以简单理解为无穷大). 这个函数是傅里叶分析中一个特殊的函数, 叫做Dirac delta函数<br>$$<br>\begin{cases}<br>\int \delta(x)dx =1 \\<br>\delta(x) =0, x \ne 0<br>\end{cases}<br>$$</p>
<p>Dirac delta函数的一个重要性质是:<br>$$\int f(x) \delta(x) dx = f(0)$$</p>
<h3 id="理想采样和重建"><a href="#理想采样和重建" class="headerlink" title="理想采样和重建"></a>理想采样和重建</h3><p>我们将采样过程用方程描述.采样实际上是将均匀分布的delta函数的无穷累加和一个叫做脉冲序列(“shah” or “impulse train”)函数相乘得到的结果.脉冲序列函数定义如下:<br>$$\bigvee_T(x) =  T \sum_{i= {-\infty}}^{\infty} \delta(x- i T)$$</p>
<p>其中T叫做采样频率,或者周期.将脉冲序列函数和原始信号相乘,就得到了均匀的无穷序列采样值.<br>$$S(x) = \bigvee_T(x)f(x) = T \sum_i \delta(x - i T)f(iT)$$</p>
<p>上面的采样信号想要重建的话,就是运行一个重建滤波函数并进行卷积操作:</p>
<p>$$\tilde{f}(x) = S(x) \otimes r(x)$$, 而\(\otimes \)的运算是:<br>$$f(x) \otimes g(x) = \int_{- \infty}^{\infty} f(x’) g(x - x’) dx’$$<br>所以可以得到:<br>$$<br>\tilde{f}(x) =  T \sum_i \delta(x - i T)f(iT)  \otimes r(x) \\<br>= \int_{- \infty}^{\infty} T \sum_i \delta(x’ - i T)f(iT) r(x - x’) dx’ \\<br> = T \sum_{i= {-\infty}}^{\infty} f(iT) r(x - iT)<br>$$<br>傅里叶变化的一个重要性质就是:两个函数的乘积的傅里叶变换等于每个函数单独傅里叶变换的卷积, 即<br>$$\mathcal{F} \{f(x)g(x)\} = F(\omega) \otimes G(\omega)$$<br>反之亦然.即空间域和频率域的卷积和相乘可以互相转化.因而上面的重建操作的卷积可以用频率域的相乘代替. shah函数及其对应的频率域表达分别是:<br>$$  \bigvee_T(x)= T \sum_i \delta(x - i T)\Longleftrightarrow  \bigvee_{1/T}(\omega) = (1/T) \sum_i \delta (\omega - i / T)$$</p>
<p>这里值得注意的一点是,shah函数的空间域和频域函数的周期是倒数关系,这意味着如果空间域的样本距离很大,那么频率域的样本距离很小.<br>因而采样信号的频率域表达\(\mathcal{F} (S(x))\)可以由\(F(\omega)\)和上面的shah的频率域函数的卷积得到.而将函数与delta函数进行卷积得到的就是原函数的若干复制,所以shah函数卷积会得到原始函数的无穷多的序列复制,等距分布, 周期和shah的周期一样.这就是样本序列的频率空间的表达!!</p>
<center> 

<p><img src="/2019/09/04/Sample/Fconv.png" alt="&quot;采样重建&quot;" title="Optional title"><br>Fig.2: 样本频率空间和Shah函数卷积结果</p>
</center>

<p>很显然,想要得到原始信号,应该将除了原点周围的信号全部去除掉.我们可以采用一个箱函数<strong>box function</strong>来进行这个操作. 假定箱函数宽度为\(T\),则箱函数定义是:<br>$$<br>\Pi_T(x)=\begin{cases}<br>1 / 2T, &amp; \text{如果$ \vert{x}\vert &lt;T $} \\<br>0, &amp; \text{其他情况}<br>\end{cases}<br>$$<br>频率域的相乘意味着空间域的卷积,所以这里我们相乘得到重建信号的频率表示:<br>$$\tilde{F} = (F(\omega) \otimes \bigvee_{1/T}(\omega)) \Pi_T(\omega)$$</p>
<p>我们重新梳理一遍.</p>
<p>空间域: 原始信号\(f(x)\), 周期为T的采样函数shah函数\(\bigvee_T(x)\), 采样信号\(S(x)\), 重建信号\(\tilde{f}(x)\).<br>频率域:原始信号\(F(\omega)\), shan函数\(\bigvee_{1/T}(\omega)\), 采样信号\(S(\omega)\),重建信号\(\tilde{F}(\omega)\)</p>
<p>则空间域<br>$$S(x) = \bigvee_T(x)f(x)$$<br>$$\tilde{f}(x) = S(x) \otimes r(x)$$<br>频率域:<br>$$S(\omega) = \bigvee_{1/T}(\omega) \otimes F(\omega)$$<br>$$\tilde{F}(\omega) = S(\omega)  \Pi_T(\omega)$$</p>
<p>所以要想完美重建信号,需要找到完美箱函数\(\Pi_T(x)\)的空间域表达.箱函数的逆傅里叶变换是\(sinc\)函数,所以理想的空间域重建是:<br>$$\tilde{f}(x) = S(x) \otimes r(x) = \sum_{i= - \infty}^ \infty sinc(x - i)f(i)$$</p>
<p>悲剧的是,因为sinc函数具有无限的边界,所以必须使用\(f(i)\)的所有采样值来计算空间域的某个特定值\(\tilde{f}(x)\). 实际使用只会采取一定范围之内.</p>
<center> 

<p><img src="/2019/09/04/Sample/Ideal.png" alt="&quot;采样重建&quot;" title="Optional title"><br>Fig.3: 理想重建过程</p>
</center>

<h3 id="混叠-aliasing"><a href="#混叠-aliasing" class="headerlink" title="混叠(aliasing)"></a>混叠(aliasing)</h3><p>sinc函数的无边界特性只是一个问题.另外一个理想采样和重建过程中的严重问题是其对于信号都是假设有边界的.对于无限边界的信号,如果采样频率不够的话,将会重建出不同于原信号的结果.<br>成功重建信号的关键在于精确覆盖原信号频率域\(F(\omega)\)以一定宽度的箱函数,如图三所示.但是多种情况会导致无法完美重建.第一种情况,原始信号的采样频率过低.我们之前说过空间域和频率域的shah函数的周期是倒数关系,所以空间域样本间距过大会导致频率域样本间距过小,从而使得\(F(\omega)\)的复制样本之间重叠.这种情况下无论如何也不可能完美恢复原信号.这会造成原始信号的高频部分信息泄漏到低频区域,从而遗失高频信号,并且扰乱低频信号.这些新的低频部分的干扰叫做混叠.</p>
<p>这种情况导致的混叠很容易去除:增大采样频率.采样理论告诉我们,如果原始信号的最大频率是\(\omega_0\),那么均匀采样\(\omega_s\)的频率必须大于\(2\omega_0\).\(2\omega_0\)的频率是一个分界线,叫做奈奎斯特频率(Nyquist frequency)</p>
<p>对于无边界的信号,他们在频率域无穷范围都有值,所以不可能不重叠.而不幸的是,计算及图形学中只有很少的感兴趣函数是有边界的.因而,除了单纯增大采样频率,我们必须有更好的方法来抵消混叠效果.</p>
<center> 

<p><img src="/2019/09/04/Sample/Overlapping.png" alt="&quot;采样重建&quot;" title="Optional title"><br>Fig.3: 采样频率过低</p>
</center>

<h3 id="混叠消除技术-消除走样技术-anti-aliasing"><a href="#混叠消除技术-消除走样技术-anti-aliasing" class="headerlink" title="混叠消除技术(消除走样技术, anti-aliasing)"></a>混叠消除技术(消除走样技术, anti-aliasing)</h3><p>经过前面的讨论我们知道,混叠会来源于两方面:采样频率过低和重建过程.我们将前者称为<em>prealiasing</em>, 后者称为<em>postaliasing</em>. 消除二者的技术统称为<em>antialiasing</em>.下面介绍一些除了提高采样频率之外的方法</p>
<h4 id="非均匀采样-NonUniform-Sampling"><a href="#非均匀采样-NonUniform-Sampling" class="headerlink" title="非均匀采样(NonUniform Sampling)"></a>非均匀采样(NonUniform Sampling)</h4><p>尽管自然图像函数具有无穷的频率部分, 无法从点集中完美重建,但是我们可以通过以非均匀的方式变化样本之间的间隔来减少混叠带来了的视觉影响. 用\(\xi \)表示0~1之间的随机数,则基于脉冲序列的非均匀采样点集是:<br>$$ \sum_{i=-\infty}^{\infty}(x-(i+1/2 - \xi)T)$$</p>
<p>当采样频率不足时,均匀采样和非均匀采样都不能完美重建信号,但是费均匀采样将混叠转变成了噪声,后者比前者对于人的视觉系统更容易接受.从频率域考虑,非均匀采样信号的复制的偏移更加随机,因而重建的时候会导致随机的噪声而不是相关的混叠</p>
<h4 id="自适应采样-Adaptive-Sampling"><a href="#自适应采样-Adaptive-Sampling" class="headerlink" title="自适应采样(Adaptive Sampling)"></a>自适应采样(Adaptive Sampling)</h4><p>这种方法的思想是:找到信号频率高于奈奎斯特频率的地方,在这些区域进行额外的采样.这样只会在需要的地方进行高频率采样,其他地方保持低频率采样.这种方法实际很难实现,因为找到高频率区域很困难.大多数实现方法是检查邻接采样值,找到变化很大的区域,并认为这样的区域是信号中的高频区域.<br>但是实际上邻接采样值并不能确定性的告诉我们真正发生了什么.即使两个采样值一样,中间也可能发生很大变化;而不同的值可能也不是混叠造成的.</p>
<h4 id="前置过滤-Prefiltering"><a href="#前置过滤-Prefiltering" class="headerlink" title="前置过滤(Prefiltering)"></a>前置过滤(Prefiltering)</h4><p>该方法过滤掉原始信号的高频部分.例如一些材质函数会用到.当然这会带来原始信号的信息丢失.但是通常这种缺失比混叠更不容易发现.<br>另外一种方法,会像空间域的理想重建过程<br>$$S(x) \otimes r(x) = S(x) \otimes sinc(2\omega_sx))$$<br>理想的sinc对于低频率采样会带来混叠,我们可以认为将其截断,采用一个近似sinc的低频信号来卷积.这种方法会导致原始信号的高频信号丢失,但是低频信号的混叠也会消失</p>
<h3 id="图像生成的应用"><a href="#图像生成的应用" class="headerlink" title="图像生成的应用"></a>图像生成的应用</h3><p>2D图像中的采样和重建也可以应用上面方法. 图像可以认为是位置到辐射亮度L的函数:<br>$$f(x,y)  \rightarrow L$$<br>在光线追踪中,图像中的任意位置\((x,y)\)都可以得到\(L\), 但是一般不太可能对\(f\)运用前置过滤的方法来过滤掉高频部分.因此, 将重点关注两种策略:增大采样频率, 非均匀采样.<br>更一般的,从相机发射的光线基于五个量:时间\(t\), 采样的透镜位置\((u,v)\), 图像位置\((x,y)\).对于特定的图像位置,该点的辐射亮度随着时间(场景中的运动物体)和镜头位置(相机是有限孔径的透镜)而改变</p>

    </div>
</article>
        </main>
        <aside class="aside">
            <div class="close"></div>
            <section class="aside-section">
                
    <h1>Categories</h1>

    <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/渲染/">渲染</a></li></ul>

            </section>
            <section class="aside-section">
                
    <h1>Archives</h1>

    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a></li></ul>


            </section>
            <section class="aside-section tag">
                
    <h1>Tags</h1>

    <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/pbrt/">pbrt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/伪代码/">伪代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/采样/">采样</a></li></ul>

            </section>
        </aside>
    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>